%% FILENAME: defs.tex
%% AUTHOR:   Cameron Swords

\usepackage{amsmath, listings, proof, amssymb, xspace, stmaryrd, calrsfs} %% amsthm

%%------------------------------------------------------------------------
%% DEFINITION HELPERS
%%------------------------------------------------------------------------

\newcommand{\alt}{\ \ |\ \ }
\newcommand{\comp}[1]{\llbracket #1 \rrbracket}
\newcommand{\compin}[2]{\llbracket #1 \rrbracket_{#2}}

\newcommand{\inlinexp}[1]{
{\footnotesize
 \[\begin{array}{l}
 #1
 \end{array}\]}}

\newcommand{\inlinexpa}[2]{
{\footnotesize
 \[\begin{array}{#1}
 #2
 \end{array}\]}}

\newcommand{\infr} [3] [] {\infer[\textsc{#1}]{#3}{#2}}
\newcommand{\iand}        {\qquad}

\newcommand{\Ctxt}       {\mathcal{E}}
\newcommand{\InCtxt} [1] {\Ctxt[#1]}

%%------------------------------------------------------------------------
%% REDUCTION RELATION MACROS
%%------------------------------------------------------------------------

\newcommand{\subst} [3]    {#3 [#2 / #1]}
\newcommand{\dstep} [2]    {#1 \ \Downarrow\  #2}

\newcommand{\ssosredex}        {\rightarrow}
\newcommand{\ctxtreduce}       {\mapsto}
\newcommand{\sstep}     [3] [] {#2 &\ssosredex&  #3 &\textsc{#1}}
\newcommand{\ctxtstep}  [3] [] {#2 &\ctxtreduce& #3 &\textsc{#1}}

%%------------------------------------------------------------------------
%% TYPE DEFINITION MACROS
%%------------------------------------------------------------------------

\newcommand{\funct} [2] {#1\nobreak\rightarrow\nobreak#2}
\newcommand{\boolt}     {\mathtt{bool}}

\newcommand{\typeEnv}         {\Gamma}
\newcommand{\entails}         {\vdash}
\newcommand{\judgment}   [3] {#1 \entails #2 : #3}
\newcommand{\envent}      [2] {\judgment{\typeEnv}{#1}{#2}}
\newcommand{\extenvent}   [4] {\judgment{\typeEnv, #1 : #2}{#3}{#4}}
\newcommand{\envlookup}   [3] {\infr{#1(#2) = #3}{\judgment{#1}{#2}{#3}}}

%%------------------------------------------------------------------------
%% EXPRESSION MACROS
%%------------------------------------------------------------------------

%% lambda
\newcommand{\lamdefexp}  [2] {\lambda #1.\ #2}
\newcommand{\lamdefexpa}   [2] {\begin{array}{l}\lambda#1.\\\hspace*{.5em}#2\\\end{array}}

%% let
\newcommand{\letdefexp}    [3] {\letbind{#1}{#2}\ \letin{#3}}
\newcommand{\letdefarrexp} [3] {\begin{array}{l}\letbind{#1}{#2}\\\letin{#3})\\\end{array}}

\newcommand{\letbind}  [2] {\mathsf{let}\ \lbind{#1}{#2}}
\newcommand{\letbindp} [2] {\mathsf{let}\ (\lbind{#1}{#2})}
\newcommand{\lbind}    [2] {#1=#2}
\newcommand{\letin}    [1] {\mathsf{in}\ #1}

%% if
\newcommand{\ifexp}    [3] {\ifline{#1}\ \thenline{#2}\ \elseline{#3}}
\newcommand{\ifexpa}   [3] {\begin{array}{l}\ifline{#1}\\\thenline{#2}\\\elseline{#3}\end{array}}

\newcommand{\ifop}         {\mathsf{if}}
\newcommand{\ifline}   [1] {\ifop\  #1}
\newcommand{\thenline} [1] {\mathsf{then}\ #1}
\newcommand{\elseline} [1] {\mathsf{else}\ #1}

%% opers
\newcommand{\binopdef}     {\mathit{binop}}
\newcommand{\unopdef}      {\mathit{unop}}
\newcommand{\binopexp}   [2] {\binopdef\ #1\ #2}
\newcommand{\unopexp}    [1] {\unopdef\ #1}

\newcommand{\andop}        {\mathsf{and}}
\newcommand{\orop}         {\mathsf{or}}
\newcommand{\notop}        {\mathsf{not}}
\newcommand{\equalsop}     {\mathsf{=}}

\newcommand{\andexp}     [2] {\mathsf{and}\ #1\ #2}
\newcommand{\orexp}      [2] {\mathsf{or}\ #1\ #2}
\newcommand{\notexp}     [1] {\mathsf{not}\ #1}
\newcommand{\consexp}    [2] {#1\, \mathsf{::}\, #2}

%eval
%% \newcommand{\evalin}             [2] {\llbracket\ #1\rrbracket_{#2}}

%% fresh
\newcommand{\freshvariableexp}  [2] {\exists #1 . #2}
\newcommand{\relcallexp}        [2] {#1\ #2}
\newcommand{\syntequalexp}      [2] {#1\ \equiv^{?}\ #2}
\newcommand{\conjunctionexp}     [2] {{#1}\, \wedge\, {#2}}
\newcommand{\disjunctionexp}     [2] {{#1}\, \vee\, {#2}}
\newcommand{\disjexp}            [2] {\mathsf{disj}\, #1\, #2}
\newcommand{\conjexp}            [2] {\mathsf{conj}\, #1\, #2}

%% values
\newcommand{\falsev}     {\mathsf{false}}
\newcommand{\truev}      {\mathsf{true}}

\newcommand{\succeedv}     {\mathsf{\top}}
\newcommand{\failv}      {\mathsf{\bot}}
\newcommand{\gprimev}    {g^{'}}
\newcommand{\tprimev}    {t^{'}}


\newcommand{\relEnv}         {\Gamma}
%% defines
%% \newcommand{\defrelop}   {\mathsf{defrel}}
\newcommand{\defrelexp} [3] {{#1}({#2}).{#3}}

%% monadic
\newcommand{\unitop}        {\mathsf{unit}}
\newcommand{\failop}        {\mathsf{fail}}
\newcommand{\bindop}        {\mathsf{bind}}

\newcommand{\failexp}        {\failop}
\newcommand{\unitexp}     [1] {\unitop\ #1}
\newcommand{\bindexp}  [2] {\bindop\ #1\ #2}
\newcommand{\bindexpa}   [2] {\begin{array}{l}\bindop\ #1.\\\hspace*{.5em}#2\\\end{array}}


\newcommand{\matchdefexp}   [1] {\mathsf{case}\ #1\ \mathsf{of}}
\newcommand{\matchclauseexp}   [2] {\hspace*{.5em}#1\rightarrow#2}
\newcommand{\justexp}     [1] {\mathsf{Just}\ #1}
\newcommand{\nothingv}        {\mathsf{Nothing}}

%% unification
\newcommand{\unifyexp} [3] {\mathsf{unify}{_{#3}}\ #1\ #2}


%%------------------------------------------------------------------------
%% SYNTAX OPERATIONS MACROS
%%------------------------------------------------------------------------

\newcommand{\freevarsf}   [1] {\mathscr{FV}(#1)}
\newcommand{\boundvarsf}   [1] {\mathscr{BV}(#1)}

\newcommand{\bnfrepl}         {\mathsf{::=}}
