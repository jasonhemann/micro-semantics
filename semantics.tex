\documentclass[11pt,twoside]{article}
\usepackage[inner=2cm,outer=2cm,top=3cm,bottom=3cm]{geometry} %% for changing page layout
%% add ,showframe to geometry for debugging spacing
\usepackage{graphbox} %% an extension of graphix, for \includegraphics . Possibly consider adjustbox
\usepackage{hyphenat} %% electromagnetic\hyp{}endioscopy
\usepackage[shortcuts]{extdash}
\usepackage{textcomp} %% for \oldstlyenums{}
\usepackage[activate={true,nocompatibility},%
  final,%
  tracking=true,%
  kerning=true,%
  spacing=true,%
  factor=1100,%
  stretch=10,%
  shrink=10]{microtype}%% provides tighter text formatting 
\usepackage{termcal} %% package for printing a term calendar
%% all for chapter heading changes: fncychap, quotchap and titlesec. Quotchap doesn't seem to work with this
%% \usepackage{quotchap} %% For snazzy quotes at top of chapters.
\usepackage{mathrsfs} %% fraktur fonts
\usepackage{calrsfs}  %% also fraktur kinda fonts
\usepackage{mathalfa} %% for math alphabets
\usepackage{stmaryrd}  %% for additional symbols
\usepackage{xparse}  %% fancier than newcommand for using multiple arguments &co.
\usepackage{moreverb}
%% ^^ These are the best we can do without xetex and real unicode symbols in verbatim
\usepackage{subfiles} %% a nice alternative to \include 
\usepackage[small]{titlesec} %% change subtitles, etc to smaller size
\usepackage{fancyhdr} %% improved header styling
\usepackage{lastpage} %% page n of m in footer
\usepackage[usenames,dvipsnames,svgnames,table,x11names]{xcolor} %% adds lots of colors
%% Resolves them only for pdflatex. Incompatible with xelatex.
\usepackage[utf8]{inputenc} %% special symbols
\usepackage[T1]{fontenc} %% resolves issues with OT1 font and accent characters
%% The alternate would be with \fontspec; and add \defaultfontfeatures{Ligatures=TeX} for ---
%% \usepackage{fontspec}
%% \defaultfontfeatures{Ligatures=TeX}
\usepackage[american]{babel} %% for language-ing things in pdflatex, for xelatex use polyglossia
%% \usepackage{polyglossia}
\usepackage{mathtools} %% loads amsmath, which needs to be before hyperref
\usepackage{braket} %% gives set and \mid
\usepackage{latexsym,amsfonts,amssymb,txfonts,pxfonts,wasysym} %% additional symbols 
\usepackage[normalem]{ulem} %% \uline{...}, \uwave{...},
\usepackage[ampersand]{easylist} %% alternate, simpler format for listing items.
\usepackage{bold-extra} %% \textsc{ \textbf{This is bold small capitals} }
\usepackage{booktabs} %% pretty table formatting
\usepackage{tabu} %% the currently-preferred table package
\usepackage{pdflscape} %% for \begin{landscape} ..., to change part of doc to landscape
\usepackage{multicol} %% provides multicol environment
\usepackage{morefloats} %% raise limit for max # floats above 18
\usepackage[section]{placeins} %% gives \FloatBarrier, which limits float movements
\usepackage{needspace} %% prevents page breaks right after section names
\usepackage{wrapfig} %% adds \begin{wrapfigure}[lh]{pos}[ohang]{w}
\usepackage{caption} %% for adding \caption, or table legends via \caption*
\usepackage{floatrow} %% improved version of sidecap, for horizontal caption placement
\usepackage{subcaption} %% allows subcaptions before captions 
\usepackage{footmisc} %% for customizing footnotes
\usepackage{varioref} %% adds \vref, w/context sensitivity referencing
\usepackage[pdfauthor={Jason Hemann},pdftitle={C-311 Syllabus},%
  pagebackref=false,hidelinks,breaklinks,pdftex]{hyperref}
%% \usepackage[xspace]{ellipsis} %% http://tex.stackexchange.com/questions/73467/what-is-best-method-to-insert-an-ellipsis-in-a-xetex-document#73469 ... add it after hyperref
\usepackage[all]{hypcap} %% resolves issues w/captions & hyperref. Load after hyperref
\usepackage{cleveref} %% adds \crefrange{}{} and \cpagerefrange{}
\usepackage{nag} %% should complain about old and outdated commands
\usepackage[skipabove={\baselineskip plus 5pt minus 1.5pt}, %% changes skips https://tex.stackexchange.com/questions/39867/intextsep-gives-doubled-space#40363
  skipbelow={\baselineskip plus 5pt minus 1.5pt},]{mdframed} %% adds \begin{framed} environment, and other simple framing boxes
\usepackage{fancybox} %% adds \doublebox, \ovalbox, and \shadowbox
\usepackage{minted} %% My brand new baby for highlighting source code 
%% \usepackage{alltt} %% Commented in favor of fancyvrb
%% \renewcommand{\ttdefault}{txtt} %% Commented in favor of fancyvrb
\usepackage{fancyvrb} %% provides \Verbatim mode, better verbatim commands
\usepackage{mathpartir} %% Didier Remy's typesetting for proofs. 
%% \usepackage[nottoc]{tocbibind} adds bibliography to TOC. Commented for now.
\usepackage[numbers]{natbib} %% [round, ] turning off these options, default back to standard 
%% \renewcommand{\bibsection}{} %% Removes 'References' section and section break
\usepackage{etoolbox}% http://ctan.org/pkg/etoolbox . An ifthen package replacement. 
%% \AtBeginEnvironment{easylist}{\addvspace{.5cm}}\AtEndEnvironment{easylist}{\addvspace{.5cm}}
%% \AtBeginEnvironment{tabu}{\addvspace{.5cm}}\AtEndEnvironment{tabu}{\addvspace{.5cm}}
%% For xelatex unicode support. 
%% \setmainfont{Junicode}
%% \newfontfamily\myregularfont{Junicode}
%% \newfontfamily\mychinesefont{IPAexMincho}
%% \usepackage[CJK]{ucharclasses}
%% \setTransitionsForCJK{\mychinesefont}{\myregularfont}
%% \usepackage{lmodern}
%% \usepackage{beramono} %% [scaled=0.85]
%% \usepackage{luximono} %% [scaled=0.85]
%% \usepackage{literat}
%% \renewcommand{\familydefault}{\ttdefault}
\input{defs.tex}
\setlength{\headheight}{13.6pt} %% must be >= 13.6pt

\defcitealias{friedman2008essentials}{\textbf{EOPL}}	
\defcitealias{springer1989scheme}{\textbf{SAOP}}


%% \pagestyle{fancyplain} %% from fancyhdr
%% \fancyhf{}
%% \lhead{\fancyplain{}{C311 - Principles of Programming Languages}}
%% \rhead{\fancyplain{}{\today}}
%% \fancyfoot[RO, LE] {page \thepage\ of \pageref{LastPage} }
%% \thispagestyle{plain}

%% texdef -t latex -c article -v parskip
%% \setlength{\parskip}{11pt plus 5pt minus 3pt} %% flex paragraph skipping for spacing

\numberwithin{equation}{subsection} %% turn on equation numbering at subsection level

\frenchspacing %% eliminates double spacing after period.  It's outdated. 

\VerbatimFootnotes % Required, otherwise verbatim does not work in footnotes!

\overfullrule=2cm %% for highlighting overfull boxes

\begin{document}

\section{Grammar}

\[
\begin{tabu}{r l l l}
\toprule
\multicolumn{4}{c}{\text{Expression Language}}                                    \\
\midrule
 \relEnv & \bnfrepl &                              & \text{Relation Environments} \\
         & \alt     & d_{1}, \ldots, d_{n}         &                              \\
         &          &                              &                              \\
 P       & \bnfrepl &                              & \text{Programs}              \\
         & \alt     & \relEnv\ g                   &                              \\
         &          &                              &                              \\
 d       & \bnfrepl &                              & \text{Relations}             \\
         & \alt     & \defrelexp{r}{x}{g}          &                              \\
         &          &                              &                              \\
 g       & \bnfrepl &                              & \text{Goals}                 \\
         & \alt     & \succeedv                    & \text{Trivial success}       \\
         & \alt     & \failv                       & \text{Trivial failure}       \\
         & \alt     & \syntequalexp{t}{\tprimev}   & \text{Syntactic equality}    \\
         & \alt     & \disjunctionexp{g}{\gprimev} & \text{Disjunction}           \\
         & \alt     & \conjunctionexp{g}{\gprimev} & \text{Conjunction}           \\
         & \alt     & \relcallexp{r}{t}            & \text{Relation call}         \\
         & \alt     & \freshvariableexp{x}{g}      & \text{Variable introduction} \\
         &          &                              &                              \\
 h       & \bnfrepl &                              & \text{Subset of Goals}       \\
         & \alt     & \succeedv                    & \text{Trivial success}       \\
         & \alt     & \failv                       & \text{Trivial failure}       \\
         & \alt     & \syntequalexp{t}{\tprimev}   & \text{Syntactic equality}    \\
         & \alt     & \conjunctionexp{h}{\hprimev} & \text{Conjunction}           \\
         & \alt     & \freshvariableexp{x}{h}      & \text{Variable introduction} \\
         &          &                              &                              \\

\bottomrule
\end{tabu}
\]

\[
\begin{tabu}{r l l l}
\toprule
\multicolumn{4}{c}{\text{Search Trees}}                                                                        \\
\midrule
  T           & \bnfrepl &                              & \text{Trees}                 \\
              & \alt     & .                            & \text{Empty Node}            \\
              & \alt     & g_{\sigma}                   & \text{Goal Node}             \\ 
              & \alt     & \disjunctionexp{T}{T}        & \text{Tree Disjunct Node}    \\
              & \alt     & d~T                          & \text{Delay Node}            \\
              &          &                              &                              \\ 
\bottomrule
\end{tabu}
\]

%%  r       &          &                              & \text{Relation Variables}    \\
%%         &          &                              &                              \\
%% , \gprimev
% I'm now intending the $\relcallexp{n}{t}$ form to mean relation
% invocation, and the $\freshvariableexp{x}{g}$ form to mean scoping a
% local fresh variable, as you did. I left the $\ni$ parts because a)
% it's easier to remove than to add and 2) I was cargo-culting (from
% memory, incorrectly) something Clinger did in an old
% paper~\cite{clinger1984scheme}, which I include as a secondary
% attachment. If this is not relevant because, say, syntactic domains
% are only relevant when doing denotational semantics, then yeah I'll
% scrap'em. Also, the standard parenthetic conventions apply. \\

% \vspace{.5cm}


  % \text{Relnames} & \ni &
  %                 &     &
  %                 &     &
  % \text{Rel-env}  & \ni &
  %                 &     &
  % \text{Program}  & \ni &
  %                 &     &
  %                 &     &
  % \text{Relation} & \ni &
  %                 &     &
  %                 &     &
  % \text{Goal}     & \ni &
  %                 &     &
  %                 &     &
  %                 &     &
  %                 &     &
  %                 &     &
  %                 &     &
  %                 &     &
  %                 &     &

\[
\begin{tabu}{r l l l}
\toprule
\multicolumn{4}{c}{\text{Contexts}}                                                                                  \\
\midrule
 \Ctxt[s] & \bnfrepl &                                               & \text{Stream Evaluation Contexts}        \\ 
          & \alt     & \Hole                                         &                                          \\
          & \alt     & \disjunctionexp{\succeedv_{\sigma}}{\Ctxt[s]} &                                          \\
          &          &                                               &                                          \\ 
 \Ctxt[g] & \bnfrepl &                                               & \text{Goal Evaluation Contexts}          \\
          & \alt     & \Hole                                         &                                          \\
          & \alt     & \conjunctionexp{\Ctxt[g]}{G}                  &                                          \\
          &          &                                               &                                          \\ 
 \Ctxt[t] & \bnfrepl &                                               & \text{Tree Evaluation Contexts}          \\
          & \alt     & \Hole                                         &                                          \\
          & \alt     & \disjunctionexp{\Ctxt[t]}{T}                  &                                          \\
          & \alt     & \disjunctionexp{.}{\Ctxt[t]}                  & \text{... but I don't know why this one} \\
          &          &                                               &                                          \\ 
\bottomrule
\end{tabu}
\]

\subsection{Reduction Semantics}

\[
\begin{tabu}{rclll}
\sstep[g] [FreshVar] {\InCtxtOfSig[g]{\freshvariableexp{x}{G}}}       {\InCtxtOfSig[g]{\subst{\phi}{x}{G}}}[\text{for fresh $\phi$}] \\
\sstep[g] [Unify-1]  {\InCtxtOfSig[g]{\syntequalexp{t}{\tprimev}}}    {\InCtxtOf[g]{\succeedv}[\sigma^{'}]}[\text{where $\sigma^{'} = \text{unify}(t,\tprimev,\sigma)$}] \\
\sstep[g] [Unify-2]  {\InCtxtOfSig[g]{\syntequalexp{t}{\tprimev}}}    {\InCtxtOf[g]{\failv}[\sigma_{\emptyset}]}[\text{otherwise}] \\
\sstep[g] [And-1]    {\InCtxtOfSig[g]{\conjunctionexp{\failv}{G}}}    {\InCtxtOf[g]{\failv}[\sigma_{\emptyset}]}  \\
\sstep[g] [And-2]    {\InCtxtOfSig[g]{\conjunctionexp{\succeedv}{G}}} {\InCtxtOfSig[g]{G}}  \\ 
& & & & \\
\sstep[t] [Reroot] {\InCtxt[s]{\InCtxt[t]{ .~\succeedv_{\sigma}~.}}} {\InCtxt[s]{\disjunctionexp{ (.~\succeedv_{\sigma}~.)}{\InCtxt[t]{ . }}}} \\
\sstep[t] [Prune Fail] {\InCtxt[s]{\InCtxt[t]{ .~\failv_{\sigma}~.}}} {\InCtxt[s]{\InCtxt[t]{ . }}} \\
\sstep[t] [Prune~.] {\InCtxt[s]{\InCtxt[t]{\disjunctionexp{ . }{( .~\succeedv_{\sigma}~.)}}}} {\InCtxt[s]{\InCtxt[t]{.~\succeedv_{\sigma}~.}}} \\
\sstep[t] [Step Goal] {\InCtxt[s]{\InCtxt[t]{.~\InCtxtOfSig[g]{G}~.}}} {\InCtxt[s]{\InCtxt[t]{.~\InCtxtOf[g]{G^{'}}[\sigma^{'}]~.}}}[\text{when } G_{\sigma}  \rightarrow_{g} G^{'}_{\sigma^{'}}] \\
\sstep[t] [Reln Call] {\InCtxt[s]{\InCtxt[t]{.~\InCtxtOfSig[g]{r~t}~.}}} {\InCtxt[s]{\InCtxt[t]{d~(.~\InCtxtOfSig[g]{\subst{t}{x}{G}}~.)}}}[\text{where } \relEnv(r) = (x).G] \\ 
\sstep[t] [Interleave-1] {\InCtxt[s]{\InCtxt[t]{\disjunctionexp{(d~T)}{T^{'}}}}} {\InCtxt[s]{\InCtxt[t]{d~(\disjunctionexp{T^{'}}{T})}}} \\ 
\sstep[t] [Interleave-2] {\InCtxt[s]{d~T}} {\InCtxt[s]{T}} \\ 
\end{tabu}
\]

The term language itself doesn't seem to matter, so long as we can
unify them, substitute variables into them, and the like.

\[
\begin{tabu}{r l l l}
\toprule
\multicolumn{4}{c}{\text{Term Language}}                      \\
\midrule
 t & \bnfrepl &                       & \text{Terms}          \\ 
   & \alt     & c                     & \text{Constants}      \\
   & \alt     & x                     & \text{Term Variables} \\
   & \alt     & \consexp{t}{\tprimev} & \text{Pairs}          \\ 
   &          &                       &                       \\
\bottomrule
\end{tabu}
\]

%% r c 
 % c           &          &                              &                              \\ 
 % x           &          &                              &                              \\
 %             &          &                              &                              \\
  % \text{Const}    & \ni &
  % \text{Vars}     & \ni &
  %                 &     &
  % \text{Term}     & \ni &
  %                 &     &
  %                 &     &
  %                 &     &
  %                 &     &


\section{Substitution}

The meaning of a successful unification should be a set of
equations. We can see unification as a process for solving sets of
simultaneous equations. This model generalizes nicely to symbolic
constraints beyond equality. But for this simple restricted case, the
result should be a set of equations. This doesn't guarantee efficiency
or anything, but it's fine as a first step. I don't know what
restrictions I should place on this set. Should I require that it be
an equivalent set that represents an \emph{mgu}? Or an idempotent mgu?
Should I require this set of equations be in solved form? I went the
computationally more expensive way; it ought to be optimizable from
here. I think it makes sense to talk about the meaning of a
computation w.r.t. a set of equations/a substitution in terms of an
underlying monad.

\vspace{.5cm}

\[
\begin{tabu} {rcll}
  
  \compin{\succeedv}{\sigma}                         & =                    & \unitexp{\sigma}                                                              &                                                                                   \\
  \compin{\failv}{\sigma}                            & =                    & \failexp                                                                      &                                                                                   \\
  \compin{\syntequalexp{t}{\primev{t}}}{\sigma}      & =                    & \unitexp{\{\syntequalexp{t}{\primev{t}}\} \uplus \sigma}                      & \text{where}\ \{\syntequalexp{t}{\primev{t}}\} \uplus \sigma\ \text{is unifiable} \\
  \compin{\syntequalexp{t}{\primev{t}}}{\sigma}      & =                    & \failexp                                                                      & \text{otherwise}                                                                  \\
 %%  \compin{\disjunctionexp{g}{\primev{g}}}{\sigma} & =                    & ???                                                                           &                                                                                   \\ 
 %%  \compin{\conjunctionexp{g}{\primev{g}}}{\sigma} & =                    & ???                                                                           &                                                                                   \\
 %% \compin{\freshvariableexp{x}{g}}{\sigma}         & =                    & ???                                                                           &                                                                                   \\
 %%  \compin{\defrelexp{n}{x}{g}}{\sigma}            & =                    & ???                                                                           &                                                                                   \\ 
 %%  \compin{\relEnv}{\sigma}                        & =                    & ???                                                                           &                                                                                   \\ 
 %%  \compin{P}{\sigma}                              & =                    & ???                                                                           &                                                                                   \\ 
\end{tabu}
\]

 %%  \compin{\disjunctionexp{g}{\primev{g}}}{\sigma} & =                    & \disjexp{\compin{g}{\sigma}}{\compin{\primev{g}}{\sigma}}                     &                                                                                   \\ 
 %%  \compin{\conjunctionexp{g}{\primev{g}}}{\sigma} & =                    & \bindexp{\compin{g}{\sigma}}{\lamdefexp{\sigma}{\compin{\primev{g}}{\sigma}}} &                                                                                   \\
 %% \compin{\freshvariableexp{x}{g}}{\sigma}         & =                    & ???                                                                           &                                                                                   \\
 %%  \compin{\defrelexp{n}{x}{g}}{\sigma}            & =                    & ???                                                                           &                                                                                   \\ 
 %%  \compin{\relEnv}{\sigma}                        & =                    & ???                                                                           &                                                                                   \\ 
 %%  \compin{P}{\sigma}                              & =                    & ???                                                                           &                                                                                   \\ 



\subsection{Free \& Bound Variables}

This seems like it doesn't especially matter, but they're \emph{per force}. Free variables in the term and expression languages. Relations should
have no free variables in them. Provided it's correct to be able to
separate \emph{variables} from \emph{relnames} like I've been doing. I
did manage to correct an error in relation application as a result of doing this,
which was good.

\vspace{.5cm}

\[
\begin{tabu}{l c l}
\toprule
\freevarsf{c}                            & = & \emptyset                                            \\
\freevarsf{\succeedv}                    & = & \emptyset                                            \\
\freevarsf{\failv}                       & = & \emptyset                                            \\  
\freevarsf{x}                            & = & \set{x}                                              \\
\freevarsf{\relcallexp{n}{t}}            & = & \freevarsf{t}                                        \\ 
\freevarsf{\consexp{t}{\tprimev}}        & = & \freevarsf{t} \cup \freevarsf{\tprimev}              \\
\freevarsf{\syntequalexp{t}{\tprimev}}   & = & \freevarsf{t} \cup \freevarsf{\tprimev}              \\
\freevarsf{\disjunctionexp{g}{\gprimev}} & = & \freevarsf{g} \cup \freevarsf{\gprimev}              \\
\freevarsf{\conjunctionexp{g}{\gprimev}} & = & \freevarsf{g} \cup \freevarsf{\gprimev}              \\
\freevarsf{\freshvariableexp{x}{g}}      & = & \freevarsf{g} \setminus \set{x}                      \\
\freevarsf{\defrelexp{n}{x}{g}}          & = & \freevarsf{g} \setminus \set{x}                      \\
\freevarsf{\relEnv}                      & = & \freevarsf{d_{1}} \cup \ldots \cup \freevarsf{d_{n}} \\
\freevarsf{\relEnv\ g}                   & = & \freevarsf{\relEnv} \cup \freevarsf{g}               \\
\bottomrule
\end{tabu}
\]

\vspace{.5cm}

\noindent Bound variables, defined similarly. 

\vspace{.5cm}

\[
\begin{tabu}{l c l}
\toprule
\boundvarsf{c}                            & = & \emptyset                                                   \\
\boundvarsf{\succeedv}                    & = & \emptyset                                                   \\
\boundvarsf{\failv}                       & = & \emptyset                                                   \\  
\boundvarsf{x}                            & = & \emptyset                                                   \\
\boundvarsf{\relcallexp{n}{t}}            & = & \boundvarsf{t}                                              \\ 
\boundvarsf{\consexp{t}{\tprimev}}        & = & \boundvarsf{t} \cup \boundvarsf{\tprimev}                   \\
\boundvarsf{\syntequalexp{t}{\tprimev}}   & = & \boundvarsf{t} \cup \boundvarsf{\tprimev}                   \\
\boundvarsf{\disjunctionexp{g}{\gprimev}} & = & \boundvarsf{g} \cup \boundvarsf{\gprimev}                   \\
\boundvarsf{\conjunctionexp{g}{\gprimev}} & = & \boundvarsf{g} \cup \boundvarsf{\gprimev}                   \\
\boundvarsf{\freshvariableexp{x}{g}}      & = & \boundvarsf{g} \cup \set{x}\ \text{if}\ x \in \freevarsf{g} \\
                                          & = & \boundvarsf{g}\ \text{otherwise}                            \\
\boundvarsf{\defrelexp{n}{x}{g}}          & = & \boundvarsf{g} \cup \set{x}\ \text{if}\ x \in \freevarsf{g} \\
                                          & = & \boundvarsf{g}\ \text{otherwise}                            \\
\boundvarsf{\relEnv}                      & = & \boundvarsf{d_{1}} \cup \ldots \cup \boundvarsf{d_{n}}      \\
\boundvarsf{\relEnv\ g}                   & = & \boundvarsf{\relEnv} \cup \boundvarsf{g}                    \\
\bottomrule
\end{tabu}
\] 

\section{Monadic Semantics}

Danvy et. al give semantics for a small version of an Icon-like
language~\cite{danvy2002unifying} in terms of an underlying
\emph{backtracking monad} (c.f. Hughes~\cite{Hughes1995design}). They
use this as a branching-off point for relating two different models of
backtracking: streams, and success \& failure continuations. They
describe how one could relate these models of backtracking by
Church-encoding the datatype of the one to yield the other, a
la~\cite{hughes1986novel}. Because we are agnostic as to the
particular backtracking monad we use, a definition correct for the one
should be correct for the other. Wand and Vallaincourt extend this
research to higher-order functions~\cite{wand2004relating}. My thought
was I could use this to find my interleaving backtracking monad:

\vspace{.5cm}

\begin{easylist}
& Start with an interpreter for microKanren written as cleanly as I know how.
& Massage interpreter into using a standard, non-interleaving list monad where possible. 
& Use the standard, known isomorphism between list monad and sk/fk monad in order to generate a version using the sk/fk monad.
& Coherently introduce delay in datatype, extend list monad to a ``prefixed-stream'' monad.
&& Verify that the result is still a monad. 
& Extend the standard isomporphism to one between a ``prefixed-stream'' monad and a ``success, failure, and delay-continuation''  monad. 
& Add interleaving to the latter version, extending it to an ``interleaving success, failure, and delay-continuation'' monad
&& Verify that the result is still a monad. 
& Again extend our isomorphism to derive an ``interleaving prefixed-stream'' monad.
\end{easylist}  

\vspace{.5cm}

\noindent I've done a bunch of this. Partly it's doing the obvious
components. Forget about the state for the moment. Suppose we just
ignore unification, and are instead interested in the control and
control flow.

\vspace{.5cm}


%% \[
%% \begin{tabu}{rcl}
%%   bind^{\kappa}                                   & :                    &                                                                                                                                                                   \\
%%   unit^{\kappa}                                   & :                    & a \rightarrow \uline{} \rightarrow                                                                                                                                \\
%%   fail^{\kappa}                                   & :                    &                                                                                                                                                                   \\
%%   disj^{\kappa}                                   & :                    &                                                                                                                                                                   \\
%%   delay^{\kappa}                                  & :                    &                                                                                                                                                                   \\
%% \end{tabu}
%% \]

\[
\begin{tabu}{rcl}
\compin{\cdot}{M}                         & : & \mathsf{Exp} \rightarrow M ()                                   \\
\compin{\succeedv}{M}                     & = & \unitexp{()}                                                    \\
\compin{\failv}{M}                        & = & \failop                                                         \\
\compin{\disjunctionexp{g}{\gprimev}}{M}  & = & \disjexp{\compin{g}{M}}{\compin{\gprimev}{M}}                   \\
\compin{\conjunctionexp{g}{\gprimev}}{M}  & = & \bindexp{\compin{g}{M}}{\lamdefexp{\_}{\compin{\primev{g}}{M}}} \\
\compin{\relcallexp{r}{\_}}{M}            & = & \delayexp{\compin{\relEnv(r)}{M}}                               \\
%% \compin{\freshvariableexp{x}{g}}{M}    & = & ???                                                             \\
%% \compin{\syntequalexp{t}{\tprimev}}{M} & = & ???                                                             \\
\end{tabu}
\]
  
\[
\begin{tabu}{rcl}
append  & = & \fixexp{a}{\lamdefexpa{s \primev{s}}{\threematchexp{s}%
                           {\listnilv}{\primev{s}}%
                           {\listconsexp{\sigma}{\doubleprimev{s}}}{\listconsexp{\sigma}{(a\ {\doubleprimev{s}} \primev{s})}}%
                           {\delayexp{c}}{\delayexp{(a\ \primev{s} c)}}}} \\
mappend & = & \fixexp{m}{\lamdefexpa{s g}{\threematchexp{s}%
                           {\listnilv}{\listnilv}%
                           {\listconsexp{\sigma}{\doubleprimev{s}}}{a\ (g\sigma) (m\ {\doubleprimev{s}} \primev{s})}%
                           {\delayexp{c}}{\delayexp{(a\ \primev{s} c)}}}}                                                                                    \\
                 &   &                                                                                                                                                                  \\
  bind^{S}       & = & mappend                                                                                                                                                          \\
  unit^{S}       & = & \lamdefexp{\sigma}{\listconsexp{\sigma}{\listnilv}}                                                                                                              \\
  fail^{S}       & = & \listnilv                                                                                                                                                        \\
  disj^{S}       & = & append                                                                                                                                                           \\
  delay^{S}      & = & \delayop                                                                                                                                                         \\
                 &   &                                                                                                                                                                  \\
  bind^{\kappa}  & = & \fixexp{b}{\lamdefexp{c f}{\lamdefexp{\delta\kappa\theta}{c(\lamdefexp{c}{\delta(b c f)})(\lamdefexp{a}{f a\delta\kappa\theta})}\theta}}                         \\
  unit^{\kappa}  & = & \lamdefexp{a}{\lamdefexp{\delta\kappa\theta}{\kappa a\theta}}                                                                                                    \\
  fail^{\kappa}  & = & \lamdefexp{\delta\kappa\theta}{\theta()}                                                                                                                         \\
  disj^{\kappa}  & = & \fixexp{d}{\lamdefexp{c \primev{c}}{\lamdefexp{\delta\kappa\theta}{c(\lamdefexp{c}{\delta(d \primev{c} c)})\kappa\lamdefexp{()}{\primev{c}\delta\kappa\theta}}}} \\
  delay^{\kappa} & = & \lamdefexp{a}{\lamdefexp{\delta\kappa\theta}{\delta a}}                                                                                                          \\ 
\end{tabu}
\]


\vspace{.5cm}

\begin{minted}{racket}
(define ((mdelay c) dk sk fk)
  (dk c))

(define ((unit s) dk sk fk)
  (sk s fk))

(define ((fail) dk sk fk)
  (fk))

(define ((disj c c2) dk sk fk)
  (c (lambda (c) (dk (disj c2 c)))
     sk
     (lambda () (c2 dk sk fk))))

(define ((bind c f) dk sk fk)
  (c (lambda (c) (dk (bind c f)))
     (lambda (s fk) ((f s) dk sk fk))
     fk))
\end{minted}




%% % \sstep {\InCtxtsig{\freshvariableexp{x}{G}}}    {\InCtxtsig{\subst{\phi}{x}{G}}}       {\text{where $\sigma$ is fresh}}                            \\
%% 



I don't know that I have a whole lot that I know about this here. I
think the simplest way to think about it right now is to just
\emph{show} a rewrite of a program that I'm thinking about. This isn't
done scientifically, it's to a significant degree art and guesswork
right now. But that we can combine a conjuction of equations into a
single equation, that we can lift disjunctions above conjunctions and
variable quantification, and that a disjunct that is a solution in
prenex-normal form. I believe that the interleave amounts to flipping
the subtree on the Y axis. 

\begin{Verbatim}
(append (x y (x . y)))

(call/fresh e
 (call/fresh f
   (call/fresh g 
     (conj (== (x y (x . y)) (e f g))
           (disj (conj (== e ())
                       (== f g))
                 (call/fresh a
                   (call/fresh d 
                     (conj (== (a . d) x)
                           (call/fresh r
                             (conj
                               (== g (a . r))
                               (append (d f (a . r)))))))))))))

(disj (call/fresh e
        (call/fresh f
          (call/fresh g 
            (conj (== (x y (x . y)) (e f g))
                  (conj (== e ())
                        (== f g))))))
       (call/fresh e
         (call/fresh f
           (call/fresh g 
             (conj (== (x y (x . y)) (e f g))
                   (call/fresh a
                     (call/fresh d 
                       (conj (== (a . d) x)
                             (call/fresh r
                               (conj 
                                 (== g (a . r))
                                 (append (d f (a . r)))))))))))))

(disj (call/fresh e
        (call/fresh f
          (call/fresh g 
            (conj (== (e . (x y (x . y))) (() . (e f g)))
                  (== f g)))))
       (call/fresh e
         (call/fresh f
           (call/fresh g 
             (conj (== (x y (x . y)) (e f g))
                   (call/fresh a
                     (call/fresh d 
                       (conj (== (a . d) x)
                             (call/fresh r
                               (conj
                                 (== g (a . r))
                                 (append (d f (a . r)))))))))))))

;; At this point, the first disjunct *is* an answer. 
;; If I were doing a run 1, I'd have to say this tree is in solved form. 
;; I think what we're after is saying a completed run* is a tree
;; totally in solved form.

(disj (call/fresh e
        (call/fresh f
          (call/fresh g 
            (== ((e . (x y (x . y))) . f) ((() . (e f g)) . g)))))
       (call/fresh e
         (call/fresh f
           (call/fresh g 
             (conj (== (x y (x . y)) (e f g))
                   (call/fresh a
                     (call/fresh d 
                       (conj (== (a . d) x)
                             (call/fresh r
                               (conj
                                 (== g (a . r))
                                 (append (d f (a . r)))))))))))))

(disj (call/fresh e
        (call/fresh f
          (call/fresh g 
            (== ((e . (x y (x . y))) . f) ((() . (e f g)) . g)))))
       (call/fresh e
         (call/fresh f
           (call/fresh g 
             (call/fresh a
               (call/fresh d 
                 (conj (== ((a . d) . (x y (x . y))) (x . (e f g)))
                       (call/fresh r
                         (conj
                           (== g (a . r))
                           (append (d f (a . r))))))))))))

(disj (call/fresh e
        (call/fresh f
          (call/fresh g 
            (== ((e . (x y (x . y))) . f) ((() . (e f g)) . g)))))
       (call/fresh e
         (call/fresh f
           (call/fresh g 
             (call/fresh a
               (call/fresh d 
                 (call/fresh r
                   (conj 
                     (== (g . ((a . d) . (x y (x . y)))) ((a . r) . (x . (e f g))))
                     (append (d f (a . r)))))))))))
\end{Verbatim}  


%% \subsection{Declarative (Logic) Semantics}

%% \noindent
%% \begin{tabu} to \textwidth{X[c] X[c]}
%% \toprule
%% Column 1 & Column 2\\
%% \midrule
%% 0 &  \begin{aligned}[t] x &= a \\ &=b\end{aligned}  \\
%% \bottomrule
%% \end{tabu}

\vspace{.5cm}

\bibliographystyle{plain}
\bibliography{semantics}

\end{document}




%% As a simplifying assumption, we allow unary relations. This will
%% slightly simplify the language without loss of generality. Const,
%% Vars, and Relnames are mutually disjoint sets. Additional constants
%% shouldn't matter for the term language. And the term language itself
%% shouldn't really matter for the semantics of the expression
%% language. 
